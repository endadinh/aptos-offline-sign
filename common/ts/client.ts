import {
    AptosAccount,
    AptosClient,
    HexString,
    Types,
  } from 'aptos';

  import BN from "bn.js"
  import * as ed from "@noble/ed25519";
  import * as borsh from '@project-serum/borsh';
  import { Hasher } from './hasher';
import { HashService } from '@coin98/solana-support-library';

  

  export interface MessageTypeHash {
    whitelist_id: BN,
    chain_id: number,
  }

  export const WHITELIST_LAYOUT = borsh.struct<MessageTypeHash>([
    borsh.u64('whitelist_id'),
    borsh.u8('chain_id'),
    // borsh.str('sender')
  ]);

  export function HashWhitelistMessage(
    message: MessageTypeHash,
  ): Buffer {
    const buffer = Buffer.alloc(1000)
    const span = WHITELIST_LAYOUT.encode(message, buffer)
    const serialize = buffer.subarray(0, span)    
    return serialize;
  }

  export async function signMessage(signer: AptosAccount, message: Buffer): Promise<Buffer> {
    let private_key = HexString.ensure(signer.toPrivateKeyObject().privateKeyHex).toUint8Array()
    const signature = await ed.sign(message, private_key)
    let publicKey = signer.signingKey.publicKey;
    return Buffer.from(signature)
  }

  export async function get_hash_message(client: AptosClient, message_bytes: Buffer, sender: HexString) : Promise<Buffer> { 
    let combine = Uint8Array.from(message_bytes);
    let addr_bytes = sender.toUint8Array();
    let addr_buffer = Buffer.from(addr_bytes);
    console.log('addr_bytes',HexString.fromBuffer(addr_buffer))
    let v = []
    let i = 0;
    while (i < combine.length) {
      v.push(combine[i]);
      i++;
    }
    i = 0;
    while (i < addr_bytes.length) {
      v.push(addr_bytes[i]);
      i++;
    }
    let v_buffer = Buffer.from(v);
    let msg_hash = Hasher.keckka256(v_buffer);
    console.log('msg_hash',msg_hash.toString('hex'));
    
    return msg_hash;
  }
  
  export async function signAndSendTransaction(
    client: AptosClient,
    transaction: any,
    signer: AptosAccount,
  ): Promise<void> {
    const bcsTxn = await client.signTransaction(signer, transaction);
    const pendingTxn = await client.submitTransaction(bcsTxn);
    const completedTxn = await client.waitForTransactionWithResult(pendingTxn.hash);
    if (completedTxn.type == 'user_transaction') {
      const userTxn = (completedTxn as any) as UserTransaction;
      if (!userTxn.success) {
        throw new Error(`Transaction ${userTxn.hash} committed to the blockchain but execution failed.\n     REASON: ${userTxn.vm_status}`);
      }
      console.log('userTxn',userTxn.hash)
    }
  }
  
  class UserTransaction {
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash?: string;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    // changes: Array<WriteSetChange>;
    // sender: Address;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: any;
    signature?: any;
    /**
     * Events generated by the transaction
     */
    events: Array<Event>;
    timestamp: string;
  };
  
  declare type Event = {
    guid: string;
    sequence_number: string;
    type: string;
    /**
     * The JSON representation of the event
     */
    data: any;
  };