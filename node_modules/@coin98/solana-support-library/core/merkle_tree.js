"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTreeSha256 = exports.MerkleTreeKeccak = void 0;
var hash_service_1 = require("./hash.service");
var LEVEL_ARRAY = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M'];
var SIZE_ARRAY = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
var MerkleTreeKeccak = /** @class */ (function () {
    function MerkleTreeKeccak(hashes) {
        this._tree = new MerkleTree(hashes, hash_service_1.HashService.keckka256);
    }
    MerkleTreeKeccak.prototype.height = function () {
        return this._tree.height();
    };
    MerkleTreeKeccak.prototype.nodes = function () {
        return this._tree.nodes();
    };
    MerkleTreeKeccak.prototype.root = function () {
        return this._tree.root();
    };
    MerkleTreeKeccak.prototype.proofs = function (index) {
        return this._tree.proofs(index);
    };
    return MerkleTreeKeccak;
}());
exports.MerkleTreeKeccak = MerkleTreeKeccak;
var MerkleTreeSha256 = /** @class */ (function () {
    function MerkleTreeSha256(hashes) {
        this._tree = new MerkleTree(hashes, hash_service_1.HashService.sha256);
    }
    MerkleTreeSha256.prototype.height = function () {
        return this._tree.height();
    };
    MerkleTreeSha256.prototype.nodes = function () {
        return this._tree.nodes();
    };
    MerkleTreeSha256.prototype.root = function () {
        return this._tree.root();
    };
    MerkleTreeSha256.prototype.proofs = function (index) {
        return this._tree.proofs(index);
    };
    return MerkleTreeSha256;
}());
exports.MerkleTreeSha256 = MerkleTreeSha256;
var MerkleTree = /** @class */ (function () {
    function MerkleTree(hashes, hashFn) {
        // detect tree height
        for (var i = 0; i < SIZE_ARRAY.length; i++) {
            if (SIZE_ARRAY[i] >= hashes.length) {
                this._height = i + 1;
                break;
            }
        }
        while (hashes.length < SIZE_ARRAY[this._height - 1]) {
            hashes.push(Buffer.from(new Array(32)));
        }
        var leafNodes = hashes.map(function (hash, i) {
            return {
                row: LEVEL_ARRAY[0],
                index: i,
                hash: hash,
            };
        });
        this._nodes = [leafNodes];
        for (var i = 1; i < this._height; i++) {
            var subNodes = this._nodes[i - 1];
            var newNodes = [];
            for (var j = 0; j < subNodes.length; j += 2) {
                var hash0 = subNodes[j].hash;
                var hash1 = subNodes[j + 1].hash;
                var newHash = hash0.compare(hash1) <= 0
                    ? hashFn(Buffer.concat([hash0, hash1]))
                    : hashFn(Buffer.concat([hash1, hash0]));
                newNodes.push({
                    row: LEVEL_ARRAY[i],
                    index: j / 2,
                    hash: newHash,
                });
            }
            this._nodes.push(newNodes);
        }
        this._root = this._nodes[this._height - 1][0];
    }
    MerkleTree.prototype.height = function () {
        return this._height;
    };
    MerkleTree.prototype.nodes = function () {
        return this._nodes;
    };
    MerkleTree.prototype.root = function () {
        return this._root;
    };
    MerkleTree.prototype.proofs = function (index) {
        var nodes = this._nodes;
        var proofs = [];
        var currentIndex = index;
        for (var i = 0; i < nodes.length - 1; i++) {
            var proof = currentIndex % 2 == 0 ? nodes[i][currentIndex + 1] : nodes[i][currentIndex - 1];
            currentIndex = (currentIndex - (currentIndex % 2)) / 2;
            proofs.push(proof);
        }
        return proofs;
    };
    return MerkleTree;
}());
